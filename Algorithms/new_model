def basket_arb(basket: Status, components: list[tuple[Status, int]], theta, threshold):
    basket_price = basket.mid()
    underlying_price = sum(qty * comp.mid() for comp, qty in components)
    spread = basket_price - underlying_price
    basket.spread_history.append(spread)

    # Use EMA for theta
    alpha = 0.2
    if hasattr(basket, "ema_theta"):
        basket.ema_theta = alpha * spread + (1 - alpha) * basket.ema_theta
    else:
        basket.ema_theta = spread
    theta = basket.ema_theta

    norm_spread = spread - theta
    min_profit_margin = 2
    if abs(norm_spread) < threshold + min_profit_margin:
        return []

    # Determine max hedge size within limits
    max_hedge = min(
        basket.limit - abs(basket.position),
        *[
            (comp.limit - abs(comp.position)) // qty 
            for comp, qty in components
        ]
    )
    hedge_size = max(1, min(1, max_hedge))  # or tune this dynamically

    # Prevent overtrading beyond inventory bounds
    orders = []
    if norm_spread > threshold:
        # Basket is overpriced => sell basket, buy components
        orders.append(Order(basket.product, int(basket.worst_bid()), -hedge_size))
        for comp, qty in components:
            if comp.position + hedge_size * qty <= comp.limit:
                orders.append(Order(comp.product, int(comp.worst_ask()), hedge_size * qty))
    elif norm_spread < -threshold:
        # Basket is underpriced => buy basket, sell components
        orders.append(Order(basket.product, int(basket.worst_ask()), hedge_size))
        for comp, qty in components:
            if comp.position - hedge_size * qty >= -comp.limit:
                orders.append(Order(comp.product, int(comp.worst_bid()), -hedge_size * qty))

    return orders
